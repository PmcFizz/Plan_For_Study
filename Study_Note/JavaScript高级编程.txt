第四章 变量,作用域和内存的问题
JavaScript 的变量于其他语言的变量有很大区别,JavaScript变量松散类型的本质,决定了他只是子啊特定时间用于保存特定值的一个名字而已,
由于不存在定义某个变量必须要保存何种数据类型值的规则,变量的值及其数据类型可以在脚本的声明周期内改变.
4.1基本数据类型和引用数据类型
引用类型的值是保存在内存中的对象,与其他语言不通,JavaScript 不允许直接访问内存中的位置,也就是说不能直接操作对象的内存空间,在操纵对象时,实际上是操作对象的引用而不是实际的对象,为此,引用类型的值是按引用来访问的.

动态的属性:
定义基本类型值和引用类型值的方式是类似的,创建一个变量,并为变量赋值,但是,当这个值保存到变量中以后,对不同类型值可以执行的操作则不一样,对于引用类型的值,我们可以为其添加属性和方法,也亏改变和删除其属性的方法.
var person=new Object();
person.name='Nick';
alert(person.name);
我们可以这样操作引用类型 但不可以这样操作基本类型 
var name="Nick";
name.age=27
alert(name.age);

我们只能动态的为引用类型值添加属性,以便将来使用,但对基本数据值不行.

var num1=5;
var num2=num1 基本类型值的复制是创建一个新值,饭后吧该值复制到新变量分配的位置.

当一个变量向另一个变量复制引用类型的值时,同样会将存储在变量对象中的值复制一份放到新变量分配的空间中,不同的是,这个值的副本实际是一个指针,而这个指针指向存储在堆中的一个对象,复制操作结束后,二个变量实际上将引用同一个对象,因此改变其中一个变量,就会影响另一个变量.

传递参数
ECMAScript 中所有函数的参数都是按值传递的,也就是说,把函数外部的值复制给函数内部的参数,就和把值从一个变量复制到另一个变量一样,基本类型值的传递如同基本类型变量的复制一样,而引用类型值的传递,则如同引用类型变量的复制一样,
访问变量有按值和按引用二种方式, 而参数只能安值传递.

在参数传递基本类型的值时,被传递的值会被复制给一个局部变量, 在想参数传递引用类型的值时,会把这个值在内存中的地址复制给一个局部变量,因此这个局部变量会反应在函数的外部,

function addTen(num) {
	num += 10;
	return num;
}
var count=20;
var result=addTen(count);
alert(count);
alert(result);

下面一个例子是传递对象的函数
function setName(obj){
	obj.name='nick';
}
var person=new Object();
setName(person);
alert(person.name);

以上代码中创建了一个对象,并将其保存在变量person中,然后,这个对象呗传递到setName()函数中之后就被复制给了obj ,在这个函数内部,obj和person引用的是同一个对象,换句话说,即使这个对象是按值传递的,obj也会按引用来访问同一个对象,于是,当在函数内部为obj添加name属性后,函数内部的person也将会有所反应,因为person指向的对象在堆内存中只有一个,而且是全局对象,

再看下面这个例子:

function setName(obj){
	obj.name='Nicj';
	obj=new Object();
	obj.name='Greg';
}
var person=new Object();
setName(person);
alert(person.name);

这个例子再把person传递给setName()后,其name属性被设置为Nicj 然后又将一个新对象赋予给变量obj 同时将其name属性社会中给Greg 如果person 是按引用传递,那么person就会被自动修改执行name属性值Greg 的新对象, 但结果person.name的值是Nicj 这说明即使子啊函数内部修改了参数的值,但原始的引用仍保持不变,实际上,挡在函数内部重写obj时,这个变量引用的就是一个局部变量了,而这个局部变量对象会在函数执行完毕后立即销毁.

检测类型
要检测一个变量是不是基本数据类型,可以使用typeof ,typeof操作符是确定一个变量是字符串,数值,布尔值,还是undefined的最佳工具, 如果变量的值是一个对象或null 则typeof 操作符会返回object
虽然在检测基本数据类型时typeof 是非常得了的助手,但在检测应用类型的值时,这个操作符的用处不大, 为此ECMAScript 提供了instanceof 操作符


